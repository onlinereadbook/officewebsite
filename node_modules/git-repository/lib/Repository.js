/**
 * Copyright Â© 2015 Konstantin Tarkus.  All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _path = require('path');

var _utilsCp = require('./utils/cp');

var _utilsCp2 = _interopRequireDefault(_utilsCp);

var _utilsFs = require('./utils/fs');

var _utilsFs2 = _interopRequireDefault(_utilsFs);

var Repository = (function () {
  function Repository(path) {
    _classCallCheck(this, Repository);

    this.path = path;
  }

  _createClass(Repository, [{
    key: 'setRemote',
    value: function setRemote(name, url) {
      var opts, _ref, _ref2, remote;

      return regeneratorRuntime.async(function setRemote$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = { cwd: this.path };
            context$2$0.next = 3;
            return regeneratorRuntime.awrap(_utilsCp2['default'].exec('git', ['config', '--get', 'remote.' + name + '.url'], opts));

          case 3:
            _ref = context$2$0.sent;
            _ref2 = _slicedToArray(_ref, 2);
            remote = _ref2[1];

            opts.stdio = 'inherit';

            if (!remote) {
              context$2$0.next = 12;
              break;
            }

            context$2$0.next = 10;
            return regeneratorRuntime.awrap(_utilsCp2['default'].spawn('git', ['remote', 'set-url', name, url], opts));

          case 10:
            context$2$0.next = 14;
            break;

          case 12:
            context$2$0.next = 14;
            return regeneratorRuntime.awrap(_utilsCp2['default'].spawn('git', ['remote', 'add', name, url], opts));

          case 14:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'hasRef',
    value: function hasRef(repository, ref) {
      var opts, _ref3, _ref32, code, err;

      return regeneratorRuntime.async(function hasRef$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = { cwd: this.path };
            context$2$0.next = 3;
            return regeneratorRuntime.awrap(_utilsCp2['default'].exec('git', ['ls-remote', '--exit-code', repository, ref], opts));

          case 3:
            _ref3 = context$2$0.sent;
            _ref32 = _slicedToArray(_ref3, 3);
            code = _ref32[0];
            err = _ref32[2];

            if (!(code === 2)) {
              context$2$0.next = 11;
              break;
            }

            return context$2$0.abrupt('return', false);

          case 11:
            if (!(code === 0)) {
              context$2$0.next = 13;
              break;
            }

            return context$2$0.abrupt('return', true);

          case 13:
            throw new Error(err);

          case 14:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'config',
    value: function config(key, value) {
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var opts = { cwd: this.path, stdio: 'inherit' };
      var args = ['config', key, value];
      if (options.global) {
        args.push('--global');
      }
      return _utilsCp2['default'].spawn('git', args, opts);
    }
  }, {
    key: 'add',
    value: function add(files) {
      return this.addFiles(files);
    }
  }, {
    key: 'addFiles',
    value: function addFiles(files) {
      var opts = { cwd: this.path, stdio: 'inherit' };
      return _utilsCp2['default'].spawn('git', ['add'].concat(_toConsumableArray(files.split(/\s+/))), opts);
    }
  }, {
    key: 'commit',
    value: function commit(message) {
      var opts = { cwd: this.path, stdio: 'inherit' };
      return _utilsCp2['default'].spawn('git', ['commit', '-m', message], opts);
    }
  }, {
    key: 'push',
    value: function push() {
      var remote = arguments.length <= 0 || arguments[0] === undefined ? 'origin' : arguments[0];
      var branch = arguments.length <= 1 || arguments[1] === undefined ? 'master' : arguments[1];
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var opts = { cwd: this.path, stdio: 'inherit' };
      var args = ['push', remote, branch];
      if (options.force) {
        args.push('--force');
      }
      return _utilsCp2['default'].spawn('git', args, opts);
    }
  }, {
    key: 'fetch',
    value: function fetch(remote) {
      var opts = { cwd: this.path, stdio: 'inherit' };
      return _utilsCp2['default'].spawn('git', ['fetch', remote], opts);
    }
  }, {
    key: 'reset',
    value: function reset(target) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var opts = { cwd: this.path, stdio: 'inherit' };
      return _utilsCp2['default'].spawn('git', ['reset'].concat(_toConsumableArray(options.hard && ['--hard']), [target]), opts);
    }
  }, {
    key: 'clean',
    value: function clean(path) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (typeof path !== 'string') {
        options = path || options; // eslint-disable-line no-param-reassign
        path = false; // eslint-disable-line no-param-reassign
      }
      var opts = { cwd: this.path, stdio: 'inherit' };
      return _utilsCp2['default'].spawn('git', ['clean', '-d'].concat(_toConsumableArray(options.force && ['--force']), _toConsumableArray(path && [path])), opts);
    }
  }], [{
    key: 'open',
    value: function open(path) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var exists, opts, code;
      return regeneratorRuntime.async(function open$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            path = (0, _path.resolve)(process.cwd(), path); // eslint-disable-line no-param-reassign
            context$2$0.next = 3;
            return regeneratorRuntime.awrap(_utilsFs2['default'].exists(path));

          case 3:
            exists = context$2$0.sent;

            if (exists) {
              context$2$0.next = 6;
              break;
            }

            throw new Error('The directory \'' + path + '\' does not exist.');

          case 6:
            context$2$0.next = 8;
            return regeneratorRuntime.awrap(_utilsFs2['default'].exists((0, _path.join)(path, '.git')));

          case 8:
            exists = context$2$0.sent;
            opts = { cwd: path, stdio: 'inherit' };

            if (exists) {
              context$2$0.next = 20;
              break;
            }

            if (!(options.init === true)) {
              context$2$0.next = 19;
              break;
            }

            context$2$0.next = 14;
            return regeneratorRuntime.awrap(_utilsCp2['default'].spawn('git', ['init'], opts));

          case 14:
            code = context$2$0.sent;

            if (!(code !== 0)) {
              context$2$0.next = 17;
              break;
            }

            throw new Error('Failed to initialize a new Git repository in \'' + path + '\'.');

          case 17:
            context$2$0.next = 20;
            break;

          case 19:
            throw new Error('Cannot find a Git repository in \'' + path + '\'.');

          case 20:
            return context$2$0.abrupt('return', new Repository(path));

          case 21:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return Repository;
})();

exports['default'] = Repository;
module.exports = exports['default'];